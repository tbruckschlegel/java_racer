package org.odejava.ode;

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version: 1.3.20
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */


public interface OdeConstants {
  // enums and constants
  public final static String ODEJAVA_VERSION = OdeJNI.get_ODEJAVA_VERSION();
  
  public final static int dMaxUserClasses = OdeJNI.get_dMaxUserClasses();
  /**
   * Sphere Class
   */
  public final static int dSphereClass = OdeJNI.get_dSphereClass();
  /**
   * Box Class
   */
  public final static int dBoxClass = OdeJNI.get_dBoxClass();
  /**
   * Capped Cylinder Class
   */
  public final static int dCCylinderClass = OdeJNI.get_dCCylinderClass();
  /**
   * Regular flat-ended cylinder Class
   */
  public final static int dCylinderClass = OdeJNI.get_dCylinderClass();
  /**
   * Infinite plane Class (non-placeable)
   */
  public final static int dPlaneClass = OdeJNI.get_dPlaneClass();
  /**
   * Ray Class
   */
  public final static int dRayClass = OdeJNI.get_dRayClass();
  /**
   * Geometry Transform Class
   */
  public final static int dGeomTransformClass = OdeJNI.get_dGeomTransformClass();
  /**
   * Triangle Mesh Class
   */
  public final static int dTriMeshClass = OdeJNI.get_dTriMeshClass();
  public final static int dFirstSpaceClass = OdeJNI.get_dFirstSpaceClass();
  /**
   * Simple space Class
   */
  public final static int dSimpleSpaceClass = OdeJNI.get_dSimpleSpaceClass();
  /**
   * Hash table based space Class
   */
  public final static int dHashSpaceClass = OdeJNI.get_dHashSpaceClass();
  public final static int dQuadTreeSpaceClass = OdeJNI.get_dQuadTreeSpaceClass();
  public final static int dLastSpaceClass = OdeJNI.get_dLastSpaceClass();
  public final static int dFirstUserClass = OdeJNI.get_dFirstUserClass();
  public final static int dLastUserClass = OdeJNI.get_dLastUserClass();
  public final static int dGeomNumClasses = OdeJNI.get_dGeomNumClasses();
  public final static int dJointTypeNone = OdeJNI.get_dJointTypeNone();
  /**
   * A ball-and-socket joint
   */
  public final static int dJointTypeBall = OdeJNI.get_dJointTypeBall();
  /**
   * A hinge joint
   */
  public final static int dJointTypeHinge = OdeJNI.get_dJointTypeHinge();
  /**
   * A slider joint
   */
  public final static int dJointTypeSlider = OdeJNI.get_dJointTypeSlider();
  /**
   * A contact joint
   */
  public final static int dJointTypeContact = OdeJNI.get_dJointTypeContact();
  /**
   * A universal joint
   */
  public final static int dJointTypeUniversal = OdeJNI.get_dJointTypeUniversal();
  /**
   * A hinge-2 joint
   */
  public final static int dJointTypeHinge2 = OdeJNI.get_dJointTypeHinge2();
  /**
   * A fixed joint
   */
  public final static int dJointTypeFixed = OdeJNI.get_dJointTypeFixed();
  public final static int dJointTypeNull = OdeJNI.get_dJointTypeNull();
  /**
   * An angular motor joint
   */
  public final static int dJointTypeAMotor = OdeJNI.get_dJointTypeAMotor();
  /**
   * Low stop angle or position. Setting this to -dInfinity (the default value) turns off the low stop. For rotational joints, this stop must be greater than - pi to be effective.
   */
  public final static int dParamLoStop = OdeJNI.get_dParamLoStop();
  /**
   * High stop angle or position. Setting this to dInfinity (the default value) turns off the high stop. For rotational joints, this stop must be less than pi to be effective. If the high stop is less than the low stop then both stops will be ineffective.
   */
  public final static int dParamHiStop = OdeJNI.get_dParamHiStop();
  /**
   * Desired motor velocity (this will be an angular or linear velocity).
   */
  public final static int dParamVel = OdeJNI.get_dParamVel();
  /**
   * The maximum force or torque that the motor will use to achieve the desired velocity. This must always be greater than or equal to zero. Setting this to zero (the default value) turns off the motor.
   */
  public final static int dParamFMax = OdeJNI.get_dParamFMax();
  /**
   * The current joint stop/motor implementation has a small problem: when the joint is at one stop and the motor is set to move it away from the stop, too much force may be applied for one time step, causing a ``jumping'' motion. This fudge factor is used to scale this excess force. It should have a value between zero and one (the default value). If the jumping motion is too visible in a joint, the value can be reduced. Making this value too small can prevent the motor from being able to move the joint away from a stop.
   */
  public final static int dParamFudgeFactor = OdeJNI.get_dParamFudgeFactor();
  /**
   * The bouncyness of the stops. This is a restitution parameter in the range 0..1. 0 means the stops are not bouncy at all, 1 means maximum bouncyness.
   */
  public final static int dParamBounce = OdeJNI.get_dParamBounce();
  /**
   * The constraint force mixing (CFM) value used when not at a stop.
   */
  public final static int dParamCFM = OdeJNI.get_dParamCFM();
  /**
   * The error reduction parameter (ERP) used by the stops.
   */
  public final static int dParamStopERP = OdeJNI.get_dParamStopERP();
  /**
   * The constraint force mixing (CFM) value used by the stops. Together with the ERP value this can be used to get spongy or soft stops. Note that this is intended for unpowered joints, it does not really work as expected when a powered joint reaches its limit.
   */
  public final static int dParamStopCFM = OdeJNI.get_dParamStopCFM();
  /**
   * Suspension error reduction parameter (ERP). Currently this is only implemented on the hinge-2 joint.
   */
  public final static int dParamSuspensionERP = OdeJNI.get_dParamSuspensionERP();
  /**
   * Suspension constraint force mixing (CFM) value. Currently this is only implemented on the hinge-2 joint.
   */
  public final static int dParamSuspensionCFM = OdeJNI.get_dParamSuspensionCFM();
  public final static int dParamLoStop2 = OdeJNI.get_dParamLoStop2();
  public final static int dParamHiStop2 = OdeJNI.get_dParamHiStop2();
  public final static int dParamVel2 = OdeJNI.get_dParamVel2();
  public final static int dParamFMax2 = OdeJNI.get_dParamFMax2();
  public final static int dParamFudgeFactor2 = OdeJNI.get_dParamFudgeFactor2();
  public final static int dParamBounce2 = OdeJNI.get_dParamBounce2();
  public final static int dParamCFM2 = OdeJNI.get_dParamCFM2();
  public final static int dParamStopERP2 = OdeJNI.get_dParamStopERP2();
  public final static int dParamStopCFM2 = OdeJNI.get_dParamStopCFM2();
  public final static int dParamSuspensionERP2 = OdeJNI.get_dParamSuspensionERP2();
  public final static int dParamSuspensionCFM2 = OdeJNI.get_dParamSuspensionCFM2();
  public final static int dParamLoStop3 = OdeJNI.get_dParamLoStop3();
  public final static int dParamHiStop3 = OdeJNI.get_dParamHiStop3();
  public final static int dParamVel3 = OdeJNI.get_dParamVel3();
  public final static int dParamFMax3 = OdeJNI.get_dParamFMax3();
  public final static int dParamFudgeFactor3 = OdeJNI.get_dParamFudgeFactor3();
  public final static int dParamBounce3 = OdeJNI.get_dParamBounce3();
  public final static int dParamCFM3 = OdeJNI.get_dParamCFM3();
  public final static int dParamStopERP3 = OdeJNI.get_dParamStopERP3();
  public final static int dParamStopCFM3 = OdeJNI.get_dParamStopCFM3();
  public final static int dParamSuspensionERP3 = OdeJNI.get_dParamSuspensionERP3();
  public final static int dParamSuspensionCFM3 = OdeJNI.get_dParamSuspensionCFM3();
  /**
   * The AMotor axes and joint angle settings are entirely controlled by the user. This is the default mode.
   */
  public final static int dAMotorUser = OdeJNI.get_dAMotorUser();
  /**
   * Euler angles are automatically computed. The axis a1 is also automatically computed. The AMotor axes must be set correctly when in this mode, as described below. When this mode is initially set the current relative orientations of the bodies will correspond to all euler angles at zero.
   */
  public final static int dAMotorEuler = OdeJNI.get_dAMotorEuler();
  /**
   * If not set, use mu for both friction directions. If set, use mu for friction direction 1, use mu2 for friction direction 2.
   */
  public final static int dContactMu2 = OdeJNI.get_dContactMu2();
  /**
   * If set, take fdir1 as friction direction 1, otherwise automatically compute friction direction 1 to be perpendicular to the contact normal (in which case its resulting orientation is unpredictable).
   */
  public final static int dContactFDir1 = OdeJNI.get_dContactFDir1();
  /**
   * If set, the contact surface is bouncy, in other words the bodies will bounce off each other. The exact amount of bouncyness is controlled by the bounce parameter.
   */
  public final static int dContactBounce = OdeJNI.get_dContactBounce();
  /**
   * If set, the error reduction parameter of the contact normal can be set with the soft_erp parameter. This is useful to make surfaces soft.
   */
  public final static int dContactSoftERP = OdeJNI.get_dContactSoftERP();
  /**
   * If set, the constraint force mixing parameter of the contact normal can be set with the soft_cfm parameter. This is useful to make surfaces soft.
   */
  public final static int dContactSoftCFM = OdeJNI.get_dContactSoftCFM();
  /**
   * If set, the contact surface is assumed to be moving independently of the motion of the bodies. This is kind of like a conveyor belt running over the surface. When this flag is set, motion1 defines the surface velocity in friction direction 1.
   */
  public final static int dContactMotion1 = OdeJNI.get_dContactMotion1();
  /**
   * If set, the contact surface is assumed to be moving independently of the motion of the bodies. This is kind of like a conveyor belt running over the surface. When this flag is set, motion1 defines the surface velocity in friction direction 2.
   */
  public final static int dContactMotion2 = OdeJNI.get_dContactMotion2();
  /**
   * Force-dependent-slip (FDS) in friction direction 1.
   */
  public final static int dContactSlip1 = OdeJNI.get_dContactSlip1();
  /**
   * Force-dependent-slip (FDS) in friction direction 2.
   */
  public final static int dContactSlip2 = OdeJNI.get_dContactSlip2();
  public final static int dContactApprox0 = OdeJNI.get_dContactApprox0();
  /**
   * Use the friction pyramid approximation for friction direction 1. If this is not specified then the constant-force-limit approximation is used (and mu is a force limit).
   */
  public final static int dContactApprox1_1 = OdeJNI.get_dContactApprox1_1();
  /**
   * Use the friction pyramid approximation for friction direction 2. If this is not specified then the constant-force-limit approximation is used (and mu is a force limit).
   */
  public final static int dContactApprox1_2 = OdeJNI.get_dContactApprox1_2();
  /**
   * Equivalent to both dContactApprox1_1 and dContactApprox1_2.
   */
  public final static int dContactApprox1 = OdeJNI.get_dContactApprox1();
}
